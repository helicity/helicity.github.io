
c++ (C++ ? 뭐가맞는지 모르겠다.) 에 대한 단상(불만) 또 하나.

c++은 런타임을 엄청 고려하여 설계된 언어다.커미티에서 새 표준안을 결정할 때에도
컴파일러 및 런타임에서의 고려를 많이 한다고 알고 있다.
하지만 정작 표준에서는 런타임에 대한 얘기는 쏙 빼놨다. 뭐, 표준에 런타임 구조를 넣을수는 없지.
그래서 어떤 일이 벌어지냐 하면
- 런타임을 모르면 이게 왜 잘못된건지 이해할 수가 없다.
  --> 정작 표준에는 런타임을 기술하지 않으면서.
- 런타임에서 표준의 의도를 몰래 바이패스 하는 일들이 가능하다.

다음 코드를 보자

```
class C
{
private:
    static int m;
    static const int n;
public:
    C();
    int* getP1() { return &m; }
    int* getP2() { return const_cast<int*>(&n); }
    void print() { printf("m = %d, n = %d\n", m, n); }
};
int C::m = 0;
const int C::n = 0;

C::C()
: m(1) // 에러!        <--------------------(1)
, n(1) // 에러!        <--------------------(2)
{
    m = 1; // OK!     <--------------------(3)
}

int _tmain(void)
{
    C a;
    a.print();

    *a.getP1() = 1;   <---------------------(4)
    *a.getP2() = 1;   <---------------------(5)

    a.print();
	  return 0;
}
```
(1),(3)를 보면 클래스라는 관점에서 (1)은 안되고 (3)은 된다는게 불만스럽게 된다.
하지만 컴파일러를 구현하는 관점에서 보면 (1)을 어찌어찌 구현한다고 해도 (2)를 허용하는 것은 더 힘든 일이 된다.

static 멤버는 c++에서는 사실 전역변수에 클래스 이름공간과 접근권한을 살짝 덮은 것에 불과하다.
(4)를 보면 접근권한을 바이패스해서 private멤버를 직접 접근하게 된다.
(5)에서는 보통 access violation이 나게 되는데, 이게 왜그런지를 설명하려면
OS상의 프로세스가 메모리를 어떻게 관리하고 배치하는지부터 설명해야 하는 일이 된다.

그래서 모양새로 보면 c++의 멤버 static 변수는 전역변수를 대충 덮어놓고
구체적으로 별 신경안쓰는 형태로 놔둔 모양새가 되었다.
언어의 하위 호환성 때문에 static자체를 없애버리지는 못하겠지만
사실 static 이 주로 쓰이는 용도들은 대체로 c++로 쉽게 풀기 어려운 storage 관련된 꼼수을
구현하는 것을이기 때문에 뭐 결론적으로 보자면
c++이 못하는 것들이 많다는 사실을 숨기는 용도로도 잘 활용되고 있고 본다.

c++에서 static을 뺀다고 하면 (하위호환성은 고려하지 않을 때) 당장 원성이 빗발칠까? 칭찬이 쏟아질까?

