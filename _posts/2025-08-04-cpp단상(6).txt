아래와 같은 코드에서 if의 결과는 true 인가 false 인가 ?

	short a = 0x8000;
	unsigned short b = 0x8000;
	long c = a;
	long d = b;

	if(c==d)
	이후 생략..

잼민이(Gemini)한테 물어봤더니 지도 처음에 헛갈려서 true라고 했다가 자기 말이 앞뒤가 맞지않는다며 다시 정정해서 답해준다. 재밌네 이놈.

결과가 false인 이유는 아래와 같다.

short a = 0x8000 은 short a = -32768 과 같은 표현이고
unsigned short b = 0x8000 은 unsigned short b = 32768 과 동일하다.
그래서
c에는 -32768 가 들어가고 d에는 32768 가 들어간다

결론은 비트 표현 1000 0000 0000 0000 이 보존되는 것이 아니기 때문에 이런 착오가 생긴다.
내 견해로는 양 음수 자동 변환에 이런 기교를 넣어 놓은게 더 사람 헛갈리게 하는 거 같다.
(2의 보수표현으로 변환한 십진수값을 보존하는 것 보다는 비트 표현을 보존하는 편이 더 직관적이다. 기계적이기도 하고.)
(그러면 signed/unsigned 타입은 단지 read 시의 view 로만 작동하도록 하면 되잖아.)

반나절 삽질의 원인을 찾게되어 기쁘긴 하다. c++이 또 날 고생시켰네. 수고했다 오늘의 나.
