# 피타고라스 삼조 공부

오일러프로젝트 75번 풀이를 복습하다가 생각나서.

피타고라스 삼조의 3차원상 배치를 그려서 확인해봄.
Barning의 증명은 상당히 인상적인데, 만일 소수의 제너레이터를 설계할 수 있다면 이 증명의 방법론을 참고할 수 있을 것이다.


```'''

피타고라스 삼조의 제너레이터를 이용해서 만들어낸 벡터를 3d공간에 그린다.

https://en.wikipedia.org/wiki/Tree_of_primitive_Pythagorean_triples#Proofs

Barning의 제너레이터는 직선 x=y=z/sqrt(2) 을 중심으로 뻗어나가는 형태이나
Price의 제너레이터는 삼각형 영역의 테두리부터 채워나가면서 뻗어나간다. 
두 제너레이터는 같은 피타고라스 삼조를 만들어내는 것을 생각하면
plot된 결과를 보고 피타고라스 삼조의 최종 배치형태를 단독으로 짐작하는 것은 안된다는 것을 알 수 있다.

Barning의 발견과 증명은 1931년에 이루어졌으며 제너레이터에 대한 다음 증명이 포함되어 있다.
Preservation of the Pythagorean property = 피타고라스 관계를 이룬다
reservation of primitivity = 공약수가 없다
Presence of every primitive Pythagorean triple exactly once = 중복없이 피타고라스 3조공간을 다 채운다

Barning의 제너레이터는 아래와 같은데

    | 1 -2 2 |       | 1 2 2 |       | -1 2 2 |
A = | 2 -1 2 |   B = | 2 1 2 |   C = | -2 1 2 |
    | 2 -2 3 |       | 2 2 3 |       | -2 2 3 |

           | 1 2 -2 |
여기서 D = | 2 1 -2 | 을 생각해볼 수 있는데 이것을 출력해서 확인해보니
           | 2 2 -3 |
부모로 돌아가는 역할을 한다. (tr4_Barning 참고)

'''


# 제너레이터
def tr3_Barning( triple ):
    a,b,c = triple[0], triple[1], triple[2]
    triple1 = ( (+1*a-2*b+2*c),(+2*a-1*b+2*c),(+2*a-2*b+3*c) )
    triple2 = ( (+1*a+2*b+2*c),(+2*a+1*b+2*c),(+2*a+2*b+3*c) )
    triple3 = ( (-1*a+2*b+2*c),(-2*a+1*b+2*c),(-2*a+2*b+3*c) )
    return triple1, triple2, triple3

def tr4_Barning( triple ):
    a,b,c = triple[0], triple[1], triple[2]
    triple1 = ( (+1*a-2*b+2*c),(+2*a-1*b+2*c),(+2*a-2*b+3*c) )
    triple2 = ( (+1*a+2*b+2*c),(+2*a+1*b+2*c),(+2*a+2*b+3*c) )
    triple3 = ( (-1*a+2*b+2*c),(-2*a+1*b+2*c),(-2*a+2*b+3*c) )
    triple4 = ( (+1*a+2*b-2*c),(+2*a+1*b-2*c),(+2*a+2*b-3*c) )
    return triple1, triple2, triple3, triple4

def tr3_Price( triple ):
    a,b,c = triple[0], triple[1], triple[2]
    triple1 = ( (+2*a+1*b-1*c),(-2*a+2*b+2*c),(-2*a+1*b+3*c) )
    triple2 = ( (+2*a+1*b+1*c),(+2*a-2*b+2*c),(+2*a-1*b+3*c) )
    triple3 = ( (+2*a-1*b+1*c),(+2*a+2*b+2*c),(+2*a+1*b+3*c) )
    return triple1, triple2, triple3


all = []
cur = [(3,4,5)]
for i in range(8):
    all.extend(cur)
    next = []
    for t in cur:
        t1,t2,t3 = tr3_Price(t)
        next.extend((t1,t2,t3))
    cur = next

print(len(all))

from operator import itemgetter
m = max( (t for t in all), key=(lambda a: a[0]+a[1]+a[2]) )
print(m)
a = m[0]**2
b = m[1]**2
c = m[2]**2
print(a,b,c,a+b)

x,y,z = [],[],[]
for t in all:
    x.append(t[0])
    y.append(t[1])
    z.append(t[2])

# scattering 
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np 

fig = plt.figure(figsize=(10, 10))
ax = fig.add_subplot(111, projection='3d', proj_type='ortho')

ax.set_xlim3d(-20000, 20000)
ax.set_ylim3d(-20000, 20000)
ax.set_zlim3d(-20000, 20000)

ax.scatter(x, y, z, marker='.')
plt.title("ax.scatter")
plt.show()

```

