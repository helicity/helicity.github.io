c++ 에서 멤버 접근권한이 가시성을 제한하지 않는다는 점은
헤더파일 의존성 문제를 해결할 수 있는 가능성을 크게 훼손한다.

어떤 클래스A 의 private 멤버가 S1,S2,S3 이라는 심벌들 참조한다고 할 때,
A를 참조하는 클래스 B의 번역단위에서는 A클래스 선언(헤더파일)을 include 해야하고,
이때, A의 private 멤버 S1,S2,S3 의 선언을 또다시 include 해야만 하게 된다.

이 상황에서 프로그래머가 하게되는 것 몇가지를 생각해보면

1) A.h 에다가 S1.h, S2.h, S3.h 를 모두 인클루드 시켜놓는다.
  - 제일 간편하나 무거운 방법
2) A.h 를 불러쓰는 애들이 S1, S2, S3 에 대한 인클루드를 하게 한다.
  - 불러쓰는 애들이 인클루드해야 하는 헤더의 정보가 명확하지 않다. 빌드후 에러를 보고 인클루드 해야한다.
  - 불러쓰는 애가 A를 썼다가 안쓰는 경우, 불필요한 헤더 include가 남아있게 되는데, 이걸 바로 찾기가 어렵다.
    (이건 IDE에서 해주기도 할거같은데... c#은 이런건 IDE에서 빼주는 기능 있잖아..)
3) A에서 private 부분만 별도로 implementation을 분리한다.
  - struct 포인터 멤버변수를 만들고 실재 struct는 cpp에서 정의한다. (h에서는 전방선언만)
  - 확실하긴 하나 귀찮다. 모든 private 멤버를 접근할때 포인터를 한번 더 거쳐야 하니까.
  - implementation 생성/소멸 을 수동으로 해줘야 하는 것도 뭐..
4) stdafx.h에 모든것을 몰아넣는다.
  - 리빌드가 겁나 느려질 수 있다.
  - 다만, pch에 너무 의존하게 되면 인텔리센스가 깨지는 문제는 해결할 수 없다.

이 모든 난장판의 원인을 생각해보면..

1) 번역단위와 헤더 인클루드 메커니즘이 처음 생긴 시절에는 소스파일 갯수가 그다지 많지 않았을 수 있다.
2) 요즘은 웬만한 환경에서 OS 및 기반 라이브러리 인클루드 파일 갯수만 수십만개다.
3) 프로젝트 파일 관리에 대한 책임이 전적으로 개발자에게 있다.
   (c++의 스타일이 그런것 같다. 개발자가 모든것을 책임지는.ㅋㅋㅋ)
4) 가시성에 대해서는 문제제기하는 사람도 없고, 딱히 표준에서 신경쓴다거나 어떤 움직임을 보이지 않았다.

프로젝트 규모가 커지고 요구사항이 복잡할 수록, 개발을 쉽게하고 생산성을 높이기 위해서 필요성이 크다고 본다.
